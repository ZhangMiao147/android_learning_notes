# 第 2 章 里氏替换原则

## 2.1 爱恨纠葛的父子关系
　　在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：
* 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
* 提高代码的重用性；
* 子类可以形似父亲，但又异于父亲。
* 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源库的扩展接口都是通过集成父类来完成的；
* 提高产品或项目的开放性。

　　继承的缺点如下：
* 继承是侵入性的。只要继承，就必须拥有父亲的所有属性和方法；
* 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中少了些约束；
* 增加了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果 -- 大段的代码需要重构。

　　为了让单一继承原则的优势发挥最大的作用，减少弊端，解决方案就是引入里氏置换原则（Lishov Substitution Principle,LSP）。

　　什么是里氏置换原则？它有两种定义：
* 第一种定义，也是最正宗的定义：If for each  object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型）。
* 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的方法必须能透明地使用其子类的对象）。

　　第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

## 2.2 纠纷不断，规则压制
　　里氏置换原则为良好的继承定义了一个规范，一句简单的定义包含了 4 层定义。

1. 子类必须完全实现父类的方法

　　在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了 LSP 原则。

　　注意：在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了 LSP 原则。

　　注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生了 “畸变“，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

2. 子类可以有自己的个性

　　子类可以有自己的方法和属性。里氏替换原则时可以正着用，但是不能反过来用。也就是说向下转型（downcast）是不安全的，有子类出现的地方父类未必就可以出现。

3. 覆盖或实现父类的方法时输入参数可以被放大

　　里氏替换原则要求指定一个契约，就是制定好双方的开发协议，然后再各自实现，也就是父类或接口，这种设计方法也叫做 Design by Contract （契约设计）。契约制定了，也就同时制定了前置条件和后置条件，前置条件就是你要我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈，标准是什么。

　　方法中的输入参数成为前置条件。

　　同一个方法名称，子类的输入参数类型（Map）宽于子类的输入参数类型（HashMap），在子类中就是方法的重载，调用子类方法传递参数为 Map ，则会调用父类的方法。所以当子类代替父类传递到调用者中，子类的方法永远都不会被执行。

　　同一个方法名称，父类的输入参数类型（Map）宽于子类的输入参数类型（HashMap），会出现父类存在的地方，子类就未必可以存在，因为一旦把子类作为参数传入，调用者就很可能进入子类的方法范畴。使用父类调用方法传入参数 HashMap，则会调用父类自己的方法。使用子类调用方法传入参数 HashMap，则会调用子类自己的方法。但是这并不是子类覆写父类的方法，然而子类方法被运行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，传递一个这样的实现类就会 ”歪曲“ 了父类的意图，引起一堆意想不到的业务逻辑混乱。

 　　所以子类中的方法的前置条件必须与超类中被覆写的方法的前置条件相同或更宽松。

4. 覆写或实现父类的方法时输出结果可能被缩小

 　　父类的一个方法的返回值是一个类型 T，子类的相同方法（重载或覆写）的返回值为 S，那么里氏替换原则就要求 S 必须小于等于 T，也就是说，要么 S 和 T 是同一个类型，要么 S 是 T 的子类。

 　　采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美。

## 2.3  最佳实践

 　　在项目中，采用里氏替换原则时，尽量避免子类的 ”个性“，一旦子类有”个性“，这个子类和父类之间的关系就很难调和了，把子类当作父类使用，子类的”个性“被抹杀 -- 委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离 -- 缺乏类替换的标准。